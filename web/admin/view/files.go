package view

import (
	"bytes"
	"compress/gzip"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strconv"
	"strings"
	"time"
)

type staticFilesFile struct {
	data  string
	mime  string
	mtime time.Time
	// size is the size before compression. If 0, it means the data is uncompressed
	size int
	// hash is a sha256 hash of the file contents. Used for the Etag, and useful for caching
	hash string
}

var staticFiles = map[string]*staticFilesFile{
	"gallery.htm": {
		data:  "\x1f\x8b\b\x00\x00\x00\x00\x00\x02\xff\xb4U_o\xdb6\x10\u007f\x8e?ō/}\xa2X\xa7{h\x12\xc9\xc0\xe6\x14X\xb1\xae\v\x06\x17۞\x82\xb3t\x96\x98R\xa4J\x1e\xfd\xa7E\xbf\xfb@\xcavR\xc4@\xd1`y\x12%\xde\xef\xcfݑ\xa7\xf2\xa7\xeb?\xe7\x8b\u007fo\xde@ǽ\x81\x9b\x0f\xbf\xbe{;\a!\x95\xfa\xfb\xd5\\\xa9\xeb\xc55\xfc\xf3\xdb\xe2\x8fw0-^\xc2£\r\x9a\xb5\xb3h\x94z\xf3^\x80蘇K\xa56\x9bM\xb1yU8ߪ\xc5_j\x9b\xb8\xa6\t\xbc_J~\x80,\x1an\xc4lRf\xc1mol\xa8N\xd0L/..F\xb4\x00\x83\xb6\xad\xc4\xe7N\xce\xdfg a3\x9b\x9c\x95=1BBJ\xfa\x14\xf5\xba\x12sg\x99,\xcb\xc5n \x01\xf5\xf8V\t\xa6-\xab\xc4t\x05u\x87>\x10W\x91W\xf2\xb5P\x89\x855\x1b\x9a\xe9>\xb0\x83\x1e-\xb6T\xaa\xf1\xdb\xe4\xac4\xda~\x04O\xa6\x12\x81w\x86BG\xc4\x02:O\xabJ\xa8\xc0ȺVu\b*jit۱\xa5\x10\xd4ݧH~'\xa3.zm\x8b:\x04\x01\xbc\x1bho$\xbf\xf7\xd4h\xacD\xa8=\x91\x15G[b\xf4\x05\xeaG\xb4\x97\x18\xe8)*?\xa2\xa1{l)<\xb7J\xed\x8c\xf3K\xb7}n\x9d\x01[\xf2O\x15\t\xb5\xd7\x03C\xf0\xf5=\xe9ݱ\xe9\xd3bz^\xfc\x9c\x1b\u007f\xf7-\xfd\x1d\xaeq\xc4>\xa6-ո\xf3}\xfe\xa8\x93\xc4\xf4\x19%\x8aC\x17\xe4\xb3)\x8c\xf5\xff\u007f\xa9\x9b\x18\xf8v\x15m\xfd4\xde{\xe2\xd3\xd0\x14\xb1F\x0f8\xe8ۏ\xb4\x83\n^|\xf9R\xfcr\xf3\xf6w\xda}\xfd\xfa\xe2*\x11|\xc7dC\xbdS-\x1a\x93J\xf04\x93\xa5\x1agߤ\\\xbaf\x97]7z\r\xba\xa9D\xda\x10P\x1b\f\xa1\x12QˍnZb\xb9\x1f\x82\x10\xb5\xac\x9d\xb7\xe4%\x1a\x93\xb3\xc9\xd0Y\xb9r\xbe\x87\x9e\xb8sM%\x06\x17R\xaagg%\x1e\xa8\x96\x91\xd9\xd9\xc3-\x8a\x83q؈ه\xfc,\x15\xa6\xe0{\x13\x1e\x1b\xed\xc2T|\v\xbe]\xbamJ#\xe9\x9d\b??\x11~\xfe(\xfe\x04c\xf2\xa9\xed\x10\x1f\xf6Ldb\xc66\b\xb0\xd8\xd3a\xbdF\x13\xa9\x12\x02\x06\x835u\xce4\xe4+\xe1,\x01c\v\xceC\xef<\xc1Fs\a\xb5\xeb{\x84@\x03zdj\xc4\xe8\xe1\xb1\xfb|\x8a\x8f>\xf3V\x18Ў\x99\x85A\xa6\xb6\xc7  ϢJ\xe4ku驹\x82\x95\xb3,\x83\xfeL\x97\xf0\xb2xM\xfd\x95\x98A\xa9\x128\xe7\xa4RO\xc6\xd5(z|>(Dm\b\xbd\xd8\xebF\x93U\xf3\x94\x96F\a>\x96t\xd0\xf5\xf8a\x9fE4\xf9\xd4\x1c<?b\x84\xb1\xc0A\x0ehi<(\xfb\xe0R\x8dg\xae̿\xd2\xd9\xe4\xbf\x00\x00\x00\xff\xff\x96\xcc.y:\b\x00\x00",
		hash:  "aa5576da79bd237de09caf888771976f716b2afddf3d5d92c6e1b286d57bbdd4",
		mime:  "text/html; charset=utf-8",
		mtime: time.Unix(1576225013, 0),
		size:  2106,
	},
	"index.htm": {
		data:  "\x1f\x8b\b\x00\x00\x00\x00\x00\x02\xfflQ\xddn\x13=\x10\xbd\x8e\x9fb>K\xdf\x15\xdaL\x93H\x88&^_\x90\x16\xa8(\xa5\xa2[\x01W\x95\x93\x9d\xcdZx\xed`Oؤ\x15\xef\x8e\xf6\x87\x1f!\xae<sF眙c\xf5\xdf\xc5\xfbu\xf1\xf9\xf6\x12jn\x1c\xdc\u07bf\xbc\xbeZ\x83\xcc\x10?.\u0588\x17\xc5\x05|zS\xbc\xbb\x86\xd9\xf4\f\x8ah|\xb2l\x837\x0e\xf1\xf2F\x82\xac\x99\xf7KĶm\xa7\xedb\x1a\xe2\x0e\x8b\x0fx\xec\xb4f\x1dy,3\xfe\x839-\xb9\x94Z\xa8\xde\xf0\xd88\x9f\xf2\u007f\xc8\xcc\xce\xcf\xcf\a\xb6\x04g\xfc.\x97\x8fu\xb6\xbe\xe9\x89dJ-&\xaa!6\xd013\xfaz\xb0\xdfr\xb9\x0e\x9e\xc9sV\x9c\xf6$a;t\xb9d:2vJ+\xd8\xd6&&\xe2\xfc\xc0U\xf6B\xa2\x16b\xa2ز#m\x9b\xc4\x01Jj\x82\xc2\x01\x11\x13\xe5\xac\xff\x02\x91\\.\x13\x9f\x1c\xa5\x9a\x88%ԑ\xaa\\bb\xc3v\x8b۔pc\x12M\xb7)I\xe0ӞFǾo\xa8\xb4&\x97i\x1b\x89\xbc\xfc\xe5/\x87\x05\x00;\x97^\xfbo\xa6\x16\x93M(OOU\xf0\x9c%\xfbHK\x98\x9d\x9d\xfd\xbf\x02g=e5\xd9]\xcdK\x98M\xe7+hL\xdcY\xbf\x8495\xab\xefbrpO?\x91ـ(\xec-\xb4P8d'T\xa7\xddE\xb9\xd0W\xcd\xddxxZ*\xac\x17\xddԌ7\xee\x8cs\x14OR\xbf\x1e\n\x85F\xff\x9e\x1e\xf6.\x98R\xea\xfb\xfe\xedgB\x1d\x9c\x16\xca\xd9\x11\x84t\xd8\xefCdxe#U\xe1\b\xf3\xf93@\xb83\x95\x89\x16\x9ew\xf5\xba\x8e\xa1!\xa8B\x04\x1fZ\x85\xce\x0e\x02EM\xfdV`\x9c\v-\x95И\xe3Ce\x1d=ti\x80\xea\xe2x\xbb\x81\x91\x80\xbd/\x8eg\xf5\xbf\xadŏ\x00\x00\x00\xff\xff\x9a\xe8\x1d\xad\xdd\x02\x00\x00",
		hash:  "ef2848e01086fc7e5fde165ad73c958e28564ac9c1e4965b79b268105df906cb",
		mime:  "text/html; charset=utf-8",
		mtime: time.Unix(1574869728, 0),
		size:  733,
	},
	"upload.htm": {
		data:  "\x1f\x8b\b\x00\x00\x00\x00\x00\x02\xff\xb4V\u007fo\xdb6\x10\xfd\xdb\xfa\x14W\x02]\xb7?dJ\xf91,\r% u\n\xacX\xda\x05\x85\x87\xfd(\x8a\x80\x96\xce\x12S\x8aTIJ\xb6W\xf4\xbb\x0f$m'\xd9<\x14\xeb\x10\x03\xb6ȓ\u07bb\xc7\xe3;\xca\xec\xc9\xe5ϳ\xf9\xef\xd7/\xa1u\x9d\x84\xeb_^\\\xbd\x9a\x01I)\xfd\xf5xF\xe9\xe5\xfc\x12~\xfbq\xfe\xfa\n\xf2i\x06sÕ\x15Nh\xc5%\xa5/\xdf\x10 \xads\xfdsJW\xab\xd5tu<զ\xa1\xf3\xb7t\xed\xb9r\x0f\xde\x0eSw\x0f9\xad]Mʄ\x85\x84\xebN*[\x1c\xa0\xc9\xcf\xce\xce\"\x9a\x80\xe4\xaa)ȟm:{\x13\x80\xc8\xeb2\x99\xb0\x0e\x1d\a\x8fL\xf1\xe3 Ƃ̴r\xa8\\:\xdf\xf4H\xa0\x8a\xb3\x828\\;\xea\x99Ρj\xb9\xb1\xe8\x8a\xc1-\xd3\x1f\b\xf5,N8\x89\xa5\xe8\xac\xd30\xf4R\xf3\x9a\xd1\x18K&L\n\xf5\x01\fʂX\xb7\x91h[DG\xa05\xb8,\b\xb5\x8e;Q\xd1\xcaZ:\x88T\x8a\xa6u\n\xad\xa5\xb7\x1f\a4\x9bt\x10\xd3N\xa8ie-\x01\xb7\xe9q+$\xcc;\xac\x05/\x88\xad\f\xa2\"{Y$\xea\x02\xfa_r/\xb8\xc5\xc7\xcf\x12K\xf3\xf5yleD\xef\xc0\x9a\xea\x8e\xf7v_\xab|\x9a\x1fMOB\xbdn\x1f&\xb8\xe5#\x8f\xd8\u007f\x10\x97\x8c\xc6;_\xe6\x1f\x84O\x91?J\x8az\xb0\xeef9\xa8\xeaQ\xa4OE\xd7lk\xffU\xf4w\xfc\x87\xa1eB){\xf2nvy1\xbfx\x97$#7\xc0{q\xf3\x017P\xc0\xb3O\x9f\xa6\x17\u05ef~\xc2\xcd\xe7\xcf\xcfΓ\x84\xd2\xf7\xef\xbd\xe2/\x88\xaf\xb1\xd3\xf4\xff\x88f4\xf6x\xc2\x16\xbaޔ\x89_E-F\xa8$\xb7\xb6 0\x88t%\xea\x06]\xbamr\x1f\xa9\xb4QhR.%)\x93\xc9\x03\x80\xe2c\x88M\x18߅\x16\x83sZ\xed\x9c\xdep)\xd1lH\xf9\x16\xdd`\x148\rRX\xc7(\x8f0\xdbs\x05\xa2.\x88\xe1\xb5\xd06'\x0fin\x16z\x1d\xf4\xf7\\\x85ܴ\x16\xa3\xaf\xfdd\u0096\xdat\xc0+\u007f\xf6\x15\xc4\xf7\x8aku]\x90^[G\x02e,ԍ\u007f\x8e\x80\xe2\x1d\xfe-\x84\xaa\x8a\x05\xec\x06\xe9Dύ\xa3\xfeFZs\xc7\xc96ɽ\xb5\x06)>8a\x92/P\x96\x16%V\x0e\xb4B\xd0\x06:m\x10zQ\xb9\xc1\xa0eB\xf5\xc3\xce\x19K!\x91@L\"\xd1k\x8db\x14\xaen\xe2=\xaf\xb6\x17U\x1aP\xbe\xaf\x19\xdf\xd6\xefn[\x9f\x8fZ\xd4\xdffߝ\xc7\xc7+\x89ܐ2\\|5\x19\x8d\xa2\xa2@;6\xff\xfe\x068ʲ\x8cڱ!\xb0\x12\xb5k\vr\x9ce\x04Z\xf4\xe7lA\xf2ӌ\xc0(p\xf5B\xaf\v\x92\xe6\x19\xf8\xefI\x9e\xc1Q\x9e\xc5ܵ\xd1\xfd\xb6\x1ap\xe0\xc3z\xeeZ\xa8\v\xf2\x1a2\xc8\xe0\nN\xb2\xbbk~\xe2GG\xdf\xefG>v\xe6G~\x1ec\xf1\xfaGx\x8d\x1cJ\xf0\x8dZ\xd8\xfe<\xfe2\xef~X\x17\xe44{J`S\x90\xe3ӧ\xa4\xd4\x06jÛ\xfd~xߵh\x90Q\xff\xf8\x01Z\xe6\v\x12-yg\xb1\t\x1bdX\xb0\xe8x\x83\xa9\xdf!o\u07bdG\xf7\x81m\xd5\xe9 w@\xef\x1b\x8f\x8c6\xb6i\xcf\x15\xca=p\x10i\x8b\xb2G\x93\x86\xfd[\x8a5l\xf73\xa0'[\xfb\xec\x8c\xe7Ԯ\xd5\xed\xb0\xe8\x84#0r9\xf8)\x1f\x11|_\xd2\x1d\xf0\xbe_=,8\xcb\xe8Ơ\xb5\v\x9f`\xbb\xbc\xc9Õ\xb2\x85\x89\x14\xfbA\xa0ڱ\xf6\x06\x03S\x87\xd6\xf2\x06I\t\x8c\xf6\x06\x1f\xd0\x1cda\xa1\xa3\xc2\xc9\x16s1\x1a\x0f\x1e\x16\xfe7\x94\xc9_\x01\x00\x00\xff\xff\xbe\f\xd9Z'\t\x00\x00",
		hash:  "62f884687e2edadb1d1fd75026dc053bb3ed58a34835461a1c476eee2b060462",
		mime:  "text/html; charset=utf-8",
		mtime: time.Unix(1576224817, 0),
		size:  2343,
	},
}

// NotFound is called when no asset is found.
// It defaults to http.NotFound but can be overwritten
var NotFound = http.NotFound

// ServeHTTP serves a request, attempting to reply with an embedded file.
func ServeHTTP(rw http.ResponseWriter, req *http.Request) {
	path := strings.TrimPrefix(req.URL.Path, "/")
	f, ok := staticFiles[path]
	if !ok {
		if path != "" && !strings.HasSuffix(path, "/") {
			NotFound(rw, req)
			return
		}
		f, ok = staticFiles[path+"index.html"]
		if !ok {
			NotFound(rw, req)
			return
		}
	}
	header := rw.Header()
	if f.hash != "" {
		if hash := req.Header.Get("If-None-Match"); hash == f.hash {
			rw.WriteHeader(http.StatusNotModified)
			return
		}
		header.Set("ETag", f.hash)
	}
	if !f.mtime.IsZero() {
		if t, err := time.Parse(http.TimeFormat, req.Header.Get("If-Modified-Since")); err == nil && f.mtime.Before(t.Add(1*time.Second)) {
			rw.WriteHeader(http.StatusNotModified)
			return
		}
		header.Set("Last-Modified", f.mtime.UTC().Format(http.TimeFormat))
	}
	header.Set("Content-Type", f.mime)

	// Check if the asset is compressed in the binary
	if f.size == 0 {
		header.Set("Content-Length", strconv.Itoa(len(f.data)))
		io.WriteString(rw, f.data)
	} else {
		if header.Get("Content-Encoding") == "" && strings.Contains(req.Header.Get("Accept-Encoding"), "gzip") {
			header.Set("Content-Encoding", "gzip")
			header.Set("Content-Length", strconv.Itoa(len(f.data)))
			io.WriteString(rw, f.data)
		} else {
			header.Set("Content-Length", strconv.Itoa(f.size))
			reader, _ := gzip.NewReader(strings.NewReader(f.data))
			io.Copy(rw, reader)
			reader.Close()
		}
	}
}

// Server is simply ServeHTTP but wrapped in http.HandlerFunc so it can be passed into net/http functions directly.
var Server http.Handler = http.HandlerFunc(ServeHTTP)

// Open allows you to read an embedded file directly. It will return a decompressing Reader if the file is embedded in compressed format.
// You should close the Reader after you're done with it.
func Open(name string) (io.ReadCloser, error) {
	f, ok := staticFiles[name]
	if !ok {
		return nil, fmt.Errorf("Asset %s not found", name)
	}

	if f.size == 0 {
		return ioutil.NopCloser(strings.NewReader(f.data)), nil
	}
	return gzip.NewReader(strings.NewReader(f.data))
}

// Data return string content of file
func Data(name string) string {
	if f, ok := staticFiles[name]; ok {
		if f.size == 0 {
			return f.data
		}
		zr, _ := gzip.NewReader(strings.NewReader(f.data))
		var buf bytes.Buffer
		io.Copy(&buf, zr)
		zr.Close()
		return buf.String()
	}
	return ""
}

// ModTime returns the modification time of the original file.
// Useful for caching purposes
// Returns zero time if the file is not in the bundle
func ModTime(file string) (t time.Time) {
	if f, ok := staticFiles[file]; ok {
		t = f.mtime
	}
	return
}

// Hash returns the hex-encoded SHA256 hash of the original file
// Used for the Etag, and useful for caching
// Returns an empty string if the file is not in the bundle
func Hash(file string) (s string) {
	if f, ok := staticFiles[file]; ok {
		s = f.hash
	}
	return
}
